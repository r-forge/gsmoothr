\documentclass[a4paper, 12pt]{article}
\author{\href{mailto:m.robinson@garvan.org.au}{Mark Robinson}  \href{mailto:a.statham@garvan.org.au}{Aaron Statham}  \href{mailto:d.strbenac@garvan.org.au}{Dario Strbenac}}
\date{}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{graphicx}
\usepackage[tableposition=top]{caption}
\usepackage{ifthen}
\usepackage[utf8]{inputenc}
\topmargin -.5in
\headheight 0in
\headsep 0in
\oddsidemargin -.5in
\evensidemargin -.5in
\textwidth 176mm
\textheight 245mm

\usepackage{color}
\usepackage{Sweave}
\usepackage[pdftex]{hyperref}

\begin{document}
\title{\texttt{Repitools}: A collection of utilities for understanding epigenetic data.}
\maketitle

\section{Introduction}
\texttt{Repitools} is an R package to assist with the analysis of datasets typically found in epigenetics research. The main focus of the package is creating summarys of promoter tiling arrays and simple analyses of next generation sequencing, in the context of gene expression data.  Functionality for Affymetrix promoter arrays and Solexa sequencing data is presented.  However, the functions are simple to use on Nimblegen data too, usually with the only difference being an extra parameter being given.  Consult the help page of each function for how to use it on Nimblegen data.  Furthermore, there are many options for each function beyond those presented in this user manual.
\\ \\

\section{Getting the \texttt{Repitools} package} 
The package can be acquired by running the command:

<<eval=FALSE>>=
install.packages("Repitools", repos = "http://r-forge.r-project.org")
@

To get the data to use with these examples, download the \texttt{RepitoolsExamples} package from the R-Forge website:

\href{http://repitools.r-forge.r-project.org/}{http://repitools.r-forge.r-project.org/}

and install the package using \texttt{install.packages()}.  It can then be loaded by calling the function \texttt{setupExamples()}, after the package has been loaded into R (see below).

\texttt{Repitools} also depends on a number of packages, depending on the functions used. These include:

\begin{itemize}
	\item \texttt{aroma.affymetrix}
	\item \texttt{edgeR}
	\item \texttt{limma}
	\item \texttt{BSgenome}, \texttt{BSgenome.Hsapiens.UCSC.hg18}
	\item \texttt{IRanges}
	\item \texttt{ShortRead}
	\item \texttt{chipseq}
\end{itemize}

Download and install these from their respective websites (e.g. \href{http://www.bioconductor.org/}{Bioconductor}, \href{http://aroma-project.org/}{aroma.affymetrix}) before using \texttt{Repitools}.

<<loadLibs, echo = FALSE>>=
library(Repitools)
library(RepitoolsExamples)
library(limma)
library(aroma.affymetrix)
library(BSgenome.Hsapiens.UCSC.hg18)
@

\section{Setting up the \texttt{aroma.affymetrix} environment}
For the analysis of Affymetrix tiling arrays, Repitools makes heavy use of the \texttt{aroma.affymetrix} package, which requires data and their annotations to be in a specific directory structure (and must be writable by the end-user). The \texttt{RepitoolsExamples} package has the included example data files laid out correctly, and can be setup by executing:
<<aromaSetup1>>=
setupExamples()
@
Or, if you wish to copy the example data into the current working directory (for instance if the package has been installed system-wide into a non-writable location), execute instead:
<<aromaSetup2, eval=FALSE>>=
setupExamples(doCopy=TRUE)
@
For further information regarding \texttt{aroma.affymetrix}, consult the documentation at \href{http://aroma-project.org/}{http://aroma-project.org/} and specifically the vignette \href{http://aroma-project.org/node/39}{'MAT: (Promoter 1.0R) Tiling array analysis'}.

\section{Reading the example data}
The data used in these examples are largely from our recent paper\footnote{Coolen et al. (2010) Consolidation of the cancer genome into domains of repressive chromatin by long-range epigenetic silencing (LRES) reduces transcriptional plasticity. \textit{Nature Cell Biology}} where we integrated expression and epigenetic data of normal prostate epithelial cells (PrEC) and the LNCaP prostate cancer cell line. The example data includes Affymetrix Human Promoter 1.0R tiling arrays from a histone H3K9 acetylation chromatin immunoprecipitation experiment, with matching Affymetrix Human Gene 1.0ST expression arrays, and Illumina sequencing libraries. 

First, references to the chip definition file (CDF) and CEL files (containing the data) are defined.  Second, a design matrix specifying the difference ('contrast') of interest is created. Generally, the set of tiling array CEL files is MAT normalised and smoothed\footnote{Johnson et al. (2006) Model-based analysis of tiling-arrays for ChIP-chip. \textit{Proc. Natl. Acad. Sci. USA} 103: 12457-12462}, here using the \texttt{aroma.affymetrix} implementation.  Some operations take place directly on the normalized data while some analyses may make use of the smoothed values.

 
<<readCelCdf>>=
#aroma.affymetrix housekeeping
capture <- function(...) UseMethod("capture")
getNames <- function(...) UseMethod("getNames")

cdfT <- AffymetrixCdfFile$byChipType("Hs_PromPR_v02")
csT <- AffymetrixCelSet$byName("Tiling", cdf = cdfT)
#Handles probes which map to genome more than once
csTU <- convertToUnique(csT)

MN <- MatNormalization(csT, numChunks = 15)
csTMN <- process(MN)	
#Handles probes which map to genome more than once
csTMNU <- convertToUnique(csTMN)

#Describe 3 comparisons we are interested in
design <- cbind("PrEC K9Ac"=c( 0, 0,-1, 1),
               "LNCAP K9Ac"=c(-1, 1, 0, 0),
          "LNCaP-PrEC K9Ac"=c(-1, 1, 1,-1))
rownames(design) <- getNames(csT)
print(design)
MS <- MatSmoothing(csTMNU, design = design, probeWindow = 300, tag = "300bp_smoothing", nProbes = 10)
csTS <- process(MS, units = NULL)
@

Next, we perform a standard Robust Multixchip Analyis (RMA)\footnote{Irizarry et al. (2003) Summaries of Affymetrix GeneChip probe level data \textit{Nucleic Acids Research} 31(4):e15} on the example expression data.

<<RmaExpressionSteps>>=
cdfE <- AffymetrixCdfFile$byChipType("HuGene-1_0-st-v1")
csE <- AffymetrixCelSet$byName("geneExpression", cdf = cdfE)
bc <- RmaBackgroundCorrection(csE)
csEBC <- process(bc)
qn <- QuantileNormalization(csEBC, typesToUpdate = "pm")
csEN <- process(qn)
plm <- RmaPlm(csEN)
fit(plm)
ces <- getChipEffectSet(plm)
em <- log2(extractMatrix(ces))
rownames(em) <- getUnitNames(cdfE)
@

Next, we read in the positions of human genes with identifiers matched up to the Gene 1.0 ST 
platform (this was adapted from the annotation provided by Affymetrix):
<<readCsv>>=
genes <- read.csv("annotationData/humanGenomeAnnotation.csv")
em <- em[match(genes$name, rownames(em)),]
head(genes)
@

We form a design matrix to specify the average expression levels, or differential expression between LNCaP and PrEC cells:
<<designMat>>=
designE <- cbind("PrEC"=c(0, 0, 0.5, 0.5),
                "LNCaP"=c(0.5, 0.5, 0, 0),
           "LNCaP-PrEC"=c(0.5, 0.5, -0.5, -0.5))
rownames(designE) <- getNames(csE)
print(designE)
@

We apply the design matrix to each gene (to give a gene-level score for each contrast):
<<setupProbeScores>>=
emE <- em %*% designE
@

Finally, we load sequencing data for a different experiment. It has been stored compactly in a \texttt{BSgenome::GenomeDataList} object only containing the chromosome, strand and start position of each read (details on how to import data into this format are in the Section "Utility Functions").  This data is unpublished so we describe it here as just "IP" for each cell line, but we make it available in order to illustrate the examples.  Further information will be made available when published, but the details are not important for illustrating the Repitools package.

<<>>=
load("rawData/sequencing/seq_data.Rdata")
print(rs)
designSeq <- cbind("PrEC IP"=c(1, 1, 0, 0),
                  "LNCaP IP"=c(0, 0, 1, 1),
             "LNCaP-PrEC IP"=c(-1,-1, 1,1))
rownames(designSeq) <- names(rs)
print(designSeq)
@

\section{Data summaries}

\subsection{cpgBoxplots and cpgDensityPlot -- Plotting Bias/Enrichment related to CpG Density}
The function \texttt{cpgBoxplots} is used to create boxplots of intensity, with probes stratified by GC content and then grouped by the CpG density surrounding 600 bases of each probe (in our examples, we use a window of 600 bases, but this can be tailored to a given experiment). A range of probe GC content can be given, via the \texttt{gcContent} parameter, to narrow down analysis to probes with GC content in a certain range. Each level of GC content is plotted in a separate graph. The \texttt{samples} parameter must be a vector of length 2, that gives the columns of the intensity matrix to use. The number of bins that the CpG density is binned into is controlled with the \texttt{nBins} parameter. Setting the parameter \texttt{calcDiff} to \textbf{TRUE} will create a single plot of the difference of the first sample in the sample vector to the second sample.
\\ \\
\textbf{Examples:}

\setkeys{Gin}{width=7in}
<<cpgBP1, fig=TRUE, width=7, height=5>>=
cpgBoxplots(csTU, samples = c(2,1), gcContent = 11, nBins = 50)
@
\setkeys{Gin}{width=\Gwidth}

\setkeys{Gin}{width=7in}
<<cpgBP2, fig=TRUE, width=7, height=5>>=
cpgBoxplots(csTU, samples = c(2,1), gcContent = 12, nBins = 50, calcDiff = TRUE)
@
\setkeys{Gin}{width=\Gwidth}

The function \texttt{cpgDensityPlot} uses \texttt{cpgDensityCalc} (see Section "Utility Functions") on sequencing data to examine the CpG density distribution of reads, a useful quality control step for methylated DNA enrichment experiments. 

\setkeys{Gin}{width=7in}
<<cpgSeq, fig=TRUE, width=7, height=5>>=

takeSample <- function(rs, f=.1) {
  gdapply(rs, function(x) {
    p <- x[["+"]]
    n <- x[["-"]]
    list( "+"=sample(p, f*length(p)), "-"=sample(n, f*length(n)) )
  })
}

rsSub <- takeSample(rs, f=.1)  # take 10 percent of the reads

cpgDensityPlot(rsSub, seqLen=300, organism=Hsapiens)
#cpgDensityPlot(rsSub, seqLen=300, organism=Hsapiens, verbose=TRUE)
@
\setkeys{Gin}{width=\Gwidth}

\subsection{enrichmentPlot -- Plotting Enrichment over the whole genome}
Similarly, \texttt{enrichmentPlot} (which uses \texttt{enrichmentCalc}) can plot the distribution of enrichment over the whole genome, useful for quality control of any enrichment-based sequencing experiment. 

\setkeys{Gin}{width=7in}
<<enrichmentSeq, fig=TRUE, width=7, height=5>>=

enrichmentPlot(rsSub, seqLen=300, organism=Hsapiens, verbose=TRUE)
@
\setkeys{Gin}{width=\Gwidth}


\subsection{binPlots -- average signal proximal to annotation in bins}

Binned plots are a way of exploring the relationship between epigenomic signals and some external measure.  For example, it is possible to bin the tiling array or sequencing data by the level of expression and visualize the signal across a region up- and downstream of the transcription start sites. There are three types of visualization: lineplots, heatmaps and "terrain" diagrams.
\\ \\
We use expression data processed through RMA from above (the '\texttt{em}' data.frame) and use the table of annotation (the 'genes' data.frame).
\\ \\
The first time \texttt{binPlots} is called, it will create a mapping between the gene positions supplied and the probes on the tiling array, which is returned. Keeping this mapping and passing it to subsequent \texttt{binPlots} calls as the \texttt{probeMap} parameter will speed up plotting.  Here are some examples:

\setkeys{Gin}{width=7in}
<<binPlots1a, fig=TRUE, width=7, height=5>>=
lookupT <- binPlots(extract(csTS,1), coordinatesTable=genes, ordering=emE[,"PrEC", drop=FALSE], plotType="line", nbins=10)
#aroma.affymetrix maintenance
@
\setkeys{Gin}{width=\Gwidth}

\setkeys{Gin}{width=7in}
<<binPlots1b, fig=TRUE, width=7, height=5>>=
binPlots(extract(csTS,2), probeMap=lookupT, ordering=emE[,"LNCaP", drop=FALSE], plotType="line", nbins=10)
@
\setkeys{Gin}{width=\Gwidth}

\setkeys{Gin}{width=7in}
<<binPlots1c, fig=TRUE, width=7, height=5>>=
binPlots(extract(csTS,3), probeMap=lookupT, ordering=emE[,"LNCaP-PrEC", drop=FALSE], plotType="line", nbins=10)
@
\setkeys{Gin}{width=\Gwidth}


The \texttt{binPlots} functions also can plot a \texttt{heatmap} or \texttt{terrain} map, both of which benefit from an increase to the \texttt{nBins} argument.

\setkeys{Gin}{width=7in}
<<binPlots2, fig=TRUE, width=7, height=5>>=
binPlots(extract(csTS,1), probeMap=lookupT, ordering=emE[,"PrEC", drop=FALSE], plotType="heatmap", nbins=50)
@
\setkeys{Gin}{width=\Gwidth}

\setkeys{Gin}{width=7in}
<<binPlots3, fig=TRUE, width=7, height=5>>=
binPlots(extract(csTS,1), probeMap=lookupT, ordering=emE[,"PrEC", drop=FALSE], plotType="terrain", nbins=50)
@
\setkeys{Gin}{width=\Gwidth}

\setkeys{Gin}{width=7in}
<<binPlots4, fig=TRUE, width=7, height=5>>=
binPlots(rs, coordinatesTable=genes, design=designSeq[,"LNCaP IP", drop=FALSE], ordering=emE[,"LNCaP", drop=FALSE], plotType="heatmap", nbins=50, seqLen=300, libSize="lane")
@
\setkeys{Gin}{width=\Gwidth}

\subsection{Gene set analysis of epigenetic marks}
Sometimes, experiments may have a set of genes of interest (for example, genes highly expressed under a certain condition or a pathway). A number of graphs comparing the epigenetic marks of these genes, versus a random sample of genes, can be created in the one command.  A lookup table, as created previously, must be supplied  via the parameter \texttt{probeMap}. The genes of interest are given in the list \texttt{geneList}. Each element of the list can either be a logical vector for each gene, or alternatively, could be an integer vector specifying the rows of the data matrix that are of interest. The confidence interval defaults to 95\%, but can be user - defined through the parameter \texttt{confidence}. The parameter \texttt{nSamples} determines how many probes will be sampled for the null distribution (default: 1000).

The examples below illustrate the profile of a random selection of genes, with confidence bounds, as well as the profile of the gene set of interest.
\\ \\
\textbf{Example:}

\setkeys{Gin}{width=7in}
<<sigGraphs1, fig=TRUE, width=7, height=5>>=
geneList <- list("Upregulated Genes" = which(emE[,"LNCaP-PrEC"] > 1), 
                 "Downregulated Genes" = which(emE[,"LNCaP-PrEC"] < -1))
significancePlots(extract(csTS, 3), probeMap=lookupT, geneList=geneList, titles="H3K9ac Change Across Promoters")
@
\setkeys{Gin}{width=\Gwidth}

And again for sequencing data:

\setkeys{Gin}{width=7in}
<<sigGraphs2, fig=TRUE, width=7, height=5>>=
significancePlots(rs, coordinatesTable=genes, design=designSeq[,"LNCaP-PrEC IP", drop=FALSE], geneList=geneList, seqLen=300, titles="IP Change Across Promoters")
@
\setkeys{Gin}{width=\Gwidth}

\section{Untargeted global analysis of Epigenetic Marks}
To find regions that are statistically significantly different between immunoprecipitations and inputs, the \texttt{regionStats} function is used. Regions are called based on a trimmed mean score, and the score threshold is based on the lowest cutoff that gives an acceptable False Discovery Rate (FDR). The amount of trimming before calculation of the mean is given by \texttt{meanTrim}. The number of probes in the window that have to be above the threshold for the window to be called a significant region is given by \texttt{nProbes}. The FDR is calculated by randomly permuting the probe intensities a number of times, determined by \texttt{nPermutations}, and the minimum ratio of regions in the permuted sample to the actual sample is chosen as the FDR of the threshold. The threshold is progressively lowered until the FDR becomes greater than \texttt{fdrLevel}, and the previous score threshold is chosen to be used in deciding significant regions. Regions that are separated by less than \texttt{maxGap} bases are joined together into one larger region. The regions are returned as a list of data frames, in the list element \texttt{regions}. There is one data frame for each contrast.  The examples below analyze (and randomize within) chromosome 7, in the interest of saving time.
\\ \\
\textbf{Example:}

<<regionStats>>=
ind <- getCellIndices(getUniqueCdf(cdfT), unit=indexOf(getUniqueCdf(cdfT),"chr7F"), unlist=TRUE, useNames=FALSE)
col <- "LNCaP-PrEC K9Ac"
regs <- regionStats(csTMNU, design[,col, drop=FALSE], ind=ind, probeWindow = 300, verbose=FALSE)
o <- order(-abs(regs$regions[[col]]$score))
head(regs$regions[[col]][o, ])
@

It may be desired to view these regions in a graphical way. The \texttt{aroma.affymetrix} function \texttt{writeSgr} is a quick method to export the scores into a format readable by the Integrated Genome Browser. The file created is a tab-delimited text file with three columns; chromosome name, probe positon, and probe score. There are no column headings in the file.
\\ \\
\textbf{Example:}

<<sgr>>=
writeSgr(csTS)
@

This the IGB view of the top differentially K9Ac enriched TSS on the forward strand, as determined by the previous example.
\begin{figure}[h!]
\begin{center}
    \includegraphics[width=7in]{igb.png}
\end{center}
\caption{IGB view of the most differentially K9Ac enriched region.}
\end{figure}

At present, there is no analogous \texttt{regionStats} procedure for sequencing-based data.

\section{Targeted analysis of epigenetic marks}
Rather than looking across the entire genome (or entire region represented on a tiling microarray), one can target the analysis to regions of interest (e.g. promoters). The \texttt{blocksStats} procedure is a general-purpose tool for this. The function works in one of two modes. If the parameter \texttt{useAsRegions} is set to \texttt{TRUE}, the \texttt{start} and \texttt{end} columns of the \texttt{coordinatesTable} are used as the regions to consider. Otherwise, the start of the region of interest (e.g. transcription start site) is chosen based on the \texttt{strand} column, and the region to use for calculation is defined by the region that starts a number of bases upstream, defined by the parameter \texttt{upStream}, and a number of bases downstream, defined by the parameter  \texttt{downStream}. The minimum number of probes that must be present in a defined region for statistics calculations to be carried out is given by the parameter \texttt{minNRobust}. \\

Columns for Region-level statistics are added to the input \texttt{coordinatesTable} data.frame, including the average difference of probes in that specified region, t-statistics, p-values and adjusted p-values for each column of the design matrix.
\\ \\
\textbf{Example:}
<<blockStats>>=
bs <- blocksStats(csTMNU, genes, design=design, upStream=2000, downStream=2000)
o <- order(bs$pvals.LNCaP.PrEC)
head(bs[o,])
@

Quite conveniently, the same function can also be used to perform statistical analysis on sequencing data. The sequencing results are first read into a \texttt{GenomeDataList} object. There are two additional options that become available for \texttt{blocksStats} when it is being used to analyse sequencing data. The \texttt{seqLen} parameter can be used to extend the aligned reads to a certain length. Since the fragments of DNA sequenced are usually longer than the reads given by the experimental procedure, this single number argument will extend all reads based on where in the genome they align to, so that they all are \texttt{seqLen} in length.  The other argument specific to sequencing is \texttt{total.lib.size}, which is a boolean value that specifies whether to use the total number of reads genome - wide (using the \texttt{laneCounts} function), or the total number of reads falling within the starts and ends as described by \texttt{coordinatesTable}, as the library size for statistical calculations. If it is \texttt{TRUE}, the library size will the the number of reads in the whole genome. \texttt{FALSE} will mean that the number of reads in the coorinatesTable regions will be taken as the library size. The design matrix needs to be modified, since \texttt{edgeR} does pairwise comparisons. Treatments should have 1, controls -1, and others 0.\\

The \texttt{regionStats} procedure for sequencing data will return (library size) quantile-normalized counts and statistics for differential expression from the edgeR functions.
\\ \\
\textbf{Example:}

<<readSeqs>>=
statistics <- blocksStats(rs, genes, designSeq[,"LNCaP-PrEC IP", drop=FALSE], upStream=2000, downStream=2000, seqLen = 300, libSize="lane")
head(statistics)
@

The absolute number of counts within the regions can be determined with the functions \texttt{annotationCounts} and \texttt{annotationBlocksCounts}.  For example:

<<countsSeqs>>=
genes$position <- ifelse(genes$strand == "+", genes$start, genes$end)
head(genes)
counts <- annotationCounts(rs, genes, 10000, 2500, 300)
head(counts)

myregs <- data.frame(chr = c("chr2", "chr7"), start = c(5e5, 1e6), end = c(5.5e5, 1.005e6), strand = c('+', '-'), name = paste("Region",1:2))
print(myregs)
counts <- annotationBlocksCounts(rs, myregs, 200)
counts
@

\section{Utility Functions}
\texttt{Repitools} contains a number of generally useful functions.

\subsection{Importing Next Generation Sequencing Data}
After alignment of Next Generation Sequencing data to the genome of interest by an external tool (e.g Bowtie, bwa, maq, ELAND etc) we need to import the data into R for analysis. The \texttt{ShortRead} packages \texttt{AlignedRead} function performs this, but keeps a lot of data we are not interested in anymore (the sequence and quality scores for each read for instance). So we follow the method of the Bioconductor \texttt{chipseq} package which only stores each reads chromosome, position and direction in a compact \texttt{GenomeData} object.
\\ \\
\textbf{Example:}
<<seqImport, eval=FALSE>>=
require(chipseq)
rs1 <- readAligned("./", paste("^",filename,"$", sep=""), type="Bowtie")
rs1 <- as(rs1, "GenomeData")
@
We then save this \texttt{GenomeData} object as an .Rdata file for later use. When working with multiple lanes of sequencing, it is much more convenient to combine them into a single \texttt{GenomeDataList} object.
\\ \\
\textbf{Example:}
<<seqCombine, eval=FALSE>>=
rs <- GenomeDataList(list("Sample 1"=rs1, "Sample 2"=rs2))
@
This \texttt{GenomeDataList} object now can be used as input to our sequencing processing functions.

\subsection{Calculating CpG Density of Specific Regions}
To calculate the CpG density of specific regions of the genome, the \texttt{cpgDensityCalc} function can be used. The parameter \texttt{locationsTable} can be a data frame with two columns, \texttt{chr} and \texttt{position}. The number \texttt{windowSize} is how many bases upstream and downstream of position to take into account for the calculation. You can weight the CpGs as a function of distance to the centre of the region of interest, if desired.
\\ \\
\textbf{Example:}

<<cpgDens>>=
myLocations <- data.frame(chr=c("chr1", "chr17"), position=c(100000, 250000))
cpgDensityCalc(myLocations, 500, organism=Hsapiens)
@

\subsection{Reading Nimblegen Data Quickly}
Using other packages usually requires definition text files or specific directory structures. The reading has been streamlined with the function \texttt{loadSampleDirectory}, which loads all .pair files is a specified directory. The first argument, \texttt{path} is the path of the directory where the .pair files are located. Additionally, the parameter \texttt{ndf} gives a data frame representation of the releveant Nimblegen Data File, which is the output from the \texttt{processNDF} function. The \texttt{what} argument is a great time - saver. It describes how to process the intensities as they are being read into the matrix. The strings that can be passed in for this argument and their effects are:
\begin{center}
	\begin{tabular}{|c|p{12cm}|}
		\hline
		\textbf{String} & \textbf{Effect} \\
		\hline
		Cy3 & The matrix will have the $log_2$ intensity of the green channel for each array. \\
		\hline
		Cy5 & The matrix will have the $log_2$ intensity of the red channel for each array. \\
		\hline
		Cy3/Cy5 & The matrix will have the $log_2$ of the ratio of the green channel to the red channel. \\
		\hline
		Cy5/Cy3 & The matrix will have the $log_2$ of the ratio of the red channel to the green channel. \\
		\hline
		Cy3andCy5 & The matrix will have two columns for each array, the first being the $log_2$ of the green channel, and the next being the $log_2$ of the red channel. \\
		\hline
		Cy5andCy3 & The matrix will have two columns for each array, the first being the $log_2$ of the red channel, and the next being the $log_2$ of the green channel. \\
		\hline
	\end{tabular}
\end{center}

\subsection{Visualization of multiple heatmaps}

See the \texttt{multiHeatmap} example and documentation for the creating multi-panel heatmaps allowing complete control over colour scales and spacing between.  

\section{Future Directions}

Analyses of next-generation sequencing data, especially for epigenomic data, are in their infancy.  Further implementations will be made available in the near future.  Experiments are encouraged to provide feedback on the implemented routines as well as suggestions for further procedures.


\section{Environment}
This user manual was run through \texttt{Sweave} and the $\mathbb{R}$ environment had the following conditions:

<<sInfo>>=
sessionInfo()
@

\end{document}

